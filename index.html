<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Party Mask Match-3</title>
  <style>
    :root {
      --tile-size: 64px;
      --gap: 6px;
      --board-size: calc(8 * var(--tile-size) + 7 * var(--gap));
      --shadow: 0 12px 30px rgba(17, 24, 39, 0.2);
    }

    * {
      box-sizing: border-box;
      font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
    }

    body {
      margin: 0;
      background: radial-gradient(circle at top, #fff1f7, #f0f4ff 40%, #eef7ff 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 32px;
      color: #1f2937;
    }

    .app {
      display: grid;
      gap: 24px;
      grid-template-columns: auto 280px;
      align-items: start;
    }

    .panel {
      background: #ffffffcc;
      border-radius: 20px;
      padding: 20px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
    }

    h1 {
      margin: 0 0 8px;
      font-size: 28px;
    }

    .score {
      font-size: 22px;
      font-weight: 700;
      color: #7c3aed;
    }

    .hint {
      margin-top: 16px;
      font-size: 14px;
      line-height: 1.5;
      color: #4b5563;
    }

    .board {
      width: var(--board-size);
      height: var(--board-size);
      background: #ffffff;
      border-radius: 24px;
      padding: 0;
      position: relative;
      box-shadow: var(--shadow);
      display: grid;
      place-items: center;
    }

    .grid {
      width: 100%;
      height: 100%;
      position: relative;
    }

    .tile {
      position: absolute;
      width: var(--tile-size);
      height: var(--tile-size);
      border-radius: 18px;
      display: grid;
      place-items: center;
      cursor: grab;
      transition: transform 220ms ease, filter 200ms ease;
    }

    .tile:active {
      cursor: grabbing;
    }

    .tile.selected {
      filter: drop-shadow(0 6px 12px rgba(124, 58, 237, 0.45));
      transform: translate(var(--x), var(--y)) scale(1.06);
    }

    .mask {
      width: 92%;
      height: 92%;
      position: relative;
      display: grid;
      place-items: center;
      filter: drop-shadow(0 10px 18px rgba(15, 23, 42, 0.18));
    }

    .mask svg {
      width: 100%;
      height: 100%;
      display: block;
    }

    .tile.pop {
      animation: pop 320ms ease forwards;
      pointer-events: none;
    }

    @keyframes pop {
      0% { transform: translate(var(--x), var(--y)) scale(1); opacity: 1; }
      60% { transform: translate(var(--x), var(--y)) scale(1.15); opacity: 1; }
      100% { transform: translate(var(--x), var(--y)) scale(0.2); opacity: 0; }
    }

    .sparkles {
      position: absolute;
      inset: -10%;
      background: radial-gradient(circle at 20% 30%, rgba(255, 255, 255, 0.9), transparent 45%),
                  radial-gradient(circle at 80% 20%, rgba(255, 255, 255, 0.8), transparent 40%),
                  radial-gradient(circle at 50% 70%, rgba(255, 255, 255, 0.6), transparent 45%);
      animation: sparkle 320ms ease forwards;
      pointer-events: none;
    }

    @keyframes sparkle {
      0% { opacity: 0; transform: scale(0.6); }
      40% { opacity: 1; transform: scale(1); }
      100% { opacity: 0; transform: scale(1.3); }
    }

    .footer {
      margin-top: 18px;
      font-size: 12px;
      color: #6b7280;
    }

    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(15, 23, 42, 0.65);
      border-radius: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 200ms ease;
    }

    .overlay.active {
      opacity: 1;
      pointer-events: all;
    }

    .overlay-card {
      background: white;
      padding: 24px;
      border-radius: 18px;
      text-align: center;
      width: 80%;
      max-width: 260px;
      box-shadow: var(--shadow);
    }

    .overlay-card button {
      margin-top: 16px;
      background: #7c3aed;
      color: white;
      border: none;
      padding: 10px 16px;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
    }

    @media (max-width: 900px) {
      .app {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="board">
      <div id="grid" class="grid" aria-label="Oyun alanı"></div>
      <div id="overlay" class="overlay" aria-live="polite">
        <div class="overlay-card">
          <h2>Oyun Bitti</h2>
          <p>Hamlelerin bitti! Skorunu geçmeyi dene.</p>
          <button id="restart">Tekrar Oyna</button>
        </div>
      </div>
    </div>
    <div class="panel">
      <h1>Party Mask Match-3</h1>
      <div>Skor</div>
      <div id="score" class="score">0</div>
      <div style="margin-top: 12px;">Kombo</div>
      <div id="combo" class="score">x1</div>
      <div style="margin-top: 12px;">Kalan Hamle</div>
      <div id="moves" class="score">20</div>
      <div class="hint">
        Maskeleri sürükleyip bırakarak ya da tıklayıp komşu bir maskeyle yer değiştirerek eşleştirme yap.
        Aynı türden en az 3 maske yan yana gelince patlar ve yukarıdan yenileri düşer.
      </div>
      <div class="footer">8x8 parti maskesi bulmacası • Akıcı animasyonlar</div>
    </div>
  </div>

  <script>
    // Basit, anlaşılır bir Match-3 sistemi
    const gridSize = 8;
    const tileSize = 64;
    const gap = 6;
    const grid = document.getElementById("grid");
    const scoreEl = document.getElementById("score");
    const comboEl = document.getElementById("combo");
    const movesEl = document.getElementById("moves");
    const overlayEl = document.getElementById("overlay");
    const restartBtn = document.getElementById("restart");

    // Maskelerin renk paleti ve dekorları
    const maskTypes = [
      { base: "#ff6b6b", accent: "#ffe66d", gem: "#fff3b0" },
      { base: "#6ee7b7", accent: "#3b82f6", gem: "#e0f2fe" },
      { base: "#7c3aed", accent: "#22d3ee", gem: "#fef08a" },
      { base: "#f59e0b", accent: "#fde68a", gem: "#fef3c7" },
      { base: "#38bdf8", accent: "#f472b6", gem: "#fce7f3" },
      { base: "#f43f5e", accent: "#fbbf24", gem: "#fee2e2" }
    ];

    let board = [];
    let score = 0;
    let selectedTile = null;
    let isBusy = false;
    let movesLeft = 20;
    let gameOver = false;

    const positionToPixels = (row, col) => {
      const x = col * (tileSize + gap);
      const y = row * (tileSize + gap);
      return { x, y };
    };

    const updateScore = (value) => {
      score += value;
      scoreEl.textContent = score;
    };

    const updateCombo = (comboLevel) => {
      comboEl.textContent = `x${comboLevel}`;
    };

    const updateMoves = (value) => {
      movesLeft += value;
      movesEl.textContent = movesLeft;
      if (movesLeft <= 0) {
        triggerGameOver();
      }
    };

    const triggerGameOver = () => {
      gameOver = true;
      overlayEl.classList.add("active");
    };

    const resetGame = () => {
      score = 0;
      movesLeft = 20;
      gameOver = false;
      updateScore(0);
      updateCombo(1);
      updateMoves(0);
      overlayEl.classList.remove("active");
      buildBoard();
    };

    const createMaskElement = (typeIndex) => {
      const mask = document.createElement("div");
      mask.className = "mask";

      const { base, accent, gem } = maskTypes[typeIndex];
      const maskSvg = `
        <svg viewBox="0 0 100 100" aria-hidden="true">
          <defs>
            <linearGradient id="fur-${typeIndex}" x1="0" x2="1">
              <stop offset="0%" stop-color="${base}"/>
              <stop offset="100%" stop-color="${accent}"/>
            </linearGradient>
            <radialGradient id="shine-${typeIndex}" cx="30%" cy="20%" r="60%">
              <stop offset="0%" stop-color="rgba(255,255,255,0.9)"/>
              <stop offset="70%" stop-color="rgba(255,255,255,0)"/>
            </radialGradient>
          </defs>
          <!-- Fox ears -->
          <path d="M18 12 L32 10 L26 34 Z" fill="url(#fur-${typeIndex})" stroke="rgba(255,255,255,0.6)" stroke-width="2"/>
          <path d="M82 12 L68 10 L74 34 Z" fill="url(#fur-${typeIndex})" stroke="rgba(255,255,255,0.6)" stroke-width="2"/>
          <path d="M22 18 L30 16 L26 28 Z" fill="rgba(255,255,255,0.55)"/>
          <path d="M78 18 L70 16 L74 28 Z" fill="rgba(255,255,255,0.55)"/>
          <!-- Fox face -->
          <path d="M10 40 C12 20 30 16 50 16 C70 16 88 20 90 40
                   C92 60 78 78 50 90 C22 78 8 60 10 40 Z"
                fill="url(#fur-${typeIndex})" stroke="rgba(255,255,255,0.5)" stroke-width="2"/>
          <!-- Eye patches -->
          <path d="M20 46 C28 36 40 34 46 40 C40 56 28 58 20 46 Z" fill="rgba(0,0,0,0.22)"/>
          <path d="M54 40 C60 34 72 36 80 46 C72 58 60 56 54 40 Z" fill="rgba(0,0,0,0.22)"/>
          <!-- Eyes -->
          <circle cx="36" cy="48" r="3" fill="#0f172a"/>
          <circle cx="64" cy="48" r="3" fill="#0f172a"/>
          <!-- Snout -->
          <path d="M40 60 C46 70 54 70 60 60 C58 78 42 78 40 60 Z" fill="rgba(255,255,255,0.7)"/>
          <circle cx="50" cy="64" r="3" fill="#1f2937"/>
          <path d="M44 70 C48 74 52 74 56 70" stroke="rgba(0,0,0,0.35)" stroke-width="2" fill="none" stroke-linecap="round"/>
          <!-- Decorative gems -->
          <circle cx="50" cy="18" r="6" fill="${gem}" stroke="rgba(255,255,255,0.8)" stroke-width="2"/>
          <circle cx="18" cy="30" r="4" fill="${gem}" opacity="0.7"/>
          <circle cx="82" cy="30" r="4" fill="${gem}" opacity="0.7"/>
          <!-- Whiskers -->
          <path d="M16 60 C26 58 34 58 42 60" stroke="rgba(255,255,255,0.6)" stroke-width="2" fill="none" stroke-linecap="round"/>
          <path d="M58 60 C66 58 74 58 84 60" stroke="rgba(255,255,255,0.6)" stroke-width="2" fill="none" stroke-linecap="round"/>
          <rect x="10" y="10" width="80" height="80" fill="url(#shine-${typeIndex})"/>
        </svg>
      `;

      mask.innerHTML = maskSvg;
      return mask;
    };

    const createTile = (row, col, type) => {
      const tile = document.createElement("div");
      tile.className = "tile";
      tile.dataset.row = row;
      tile.dataset.col = col;
      tile.dataset.type = type;
      tile.style.setProperty("--x", `${col * (tileSize + gap)}px`);
      tile.style.setProperty("--y", `${row * (tileSize + gap)}px`);
      tile.style.transform = `translate(${col * (tileSize + gap)}px, ${row * (tileSize + gap)}px)`;

      tile.appendChild(createMaskElement(type));
      addTileEvents(tile);
      grid.appendChild(tile);
      return tile;
    };

    const addTileEvents = (tile) => {
      tile.addEventListener("pointerdown", (event) => {
        if (isBusy || gameOver) return;
        tile.setPointerCapture(event.pointerId);
        selectedTile = tile;
        tile.classList.add("selected");
      });

      tile.addEventListener("pointerup", (event) => {
        if (isBusy || gameOver || !selectedTile) return;
        const target = document.elementFromPoint(event.clientX, event.clientY);
        const targetTile = target ? target.closest(".tile") : null;
        handleTileSelection(targetTile);
      });

      tile.addEventListener("click", () => {
        if (isBusy || gameOver) return;
        handleTileSelection(tile);
      });
    };

    const handleTileSelection = (tile) => {
      if (!tile || gameOver) return;

      if (!selectedTile) {
        selectedTile = tile;
        tile.classList.add("selected");
        return;
      }

      if (tile === selectedTile) {
        tile.classList.remove("selected");
        selectedTile = null;
        return;
      }

      const rowA = Number(selectedTile.dataset.row);
      const colA = Number(selectedTile.dataset.col);
      const rowB = Number(tile.dataset.row);
      const colB = Number(tile.dataset.col);

      const isAdjacent = Math.abs(rowA - rowB) + Math.abs(colA - colB) === 1;

      if (!isAdjacent) {
        selectedTile.classList.remove("selected");
        selectedTile = tile;
        tile.classList.add("selected");
        return;
      }

      selectedTile.classList.remove("selected");
      const first = selectedTile;
      selectedTile = null;
      swapTiles(first, tile, true);
    };

    const buildBoard = () => {
      board = Array.from({ length: gridSize }, () => Array(gridSize).fill(null));
      grid.innerHTML = "";

      for (let row = 0; row < gridSize; row += 1) {
        for (let col = 0; col < gridSize; col += 1) {
          let type = getRandomType();
          // Başlangıçta eşleşme oluşmaması için
          while (createsMatch(row, col, type)) {
            type = getRandomType();
          }
          const tile = createTile(row, col, type);
          board[row][col] = tile;
        }
      }
    };

    const getRandomType = () => Math.floor(Math.random() * maskTypes.length);

    const createsMatch = (row, col, type) => {
      if (row >= 2) {
        const t1 = board[row - 1][col];
        const t2 = board[row - 2][col];
        if (t1 && t2 && Number(t1.dataset.type) === type && Number(t2.dataset.type) === type) {
          return true;
        }
      }
      if (col >= 2) {
        const t1 = board[row][col - 1];
        const t2 = board[row][col - 2];
        if (t1 && t2 && Number(t1.dataset.type) === type && Number(t2.dataset.type) === type) {
          return true;
        }
      }
      return false;
    };

    const swapTiles = async (tileA, tileB, checkMatches) => {
      if (isBusy || gameOver) return;
      isBusy = true;

      swapInBoard(tileA, tileB);
      moveTile(tileA);
      moveTile(tileB);

      await wait(240);

      if (checkMatches) {
        const matches = findMatches();
        if (matches.length === 0) {
          swapInBoard(tileA, tileB);
          moveTile(tileA);
          moveTile(tileB);
          await wait(240);
        } else {
          updateMoves(-1);
          updateCombo(1);
          await resolveMatches(matches, 1);
        }
      }

      isBusy = false;
    };

    const swapInBoard = (tileA, tileB) => {
      const rowA = Number(tileA.dataset.row);
      const colA = Number(tileA.dataset.col);
      const rowB = Number(tileB.dataset.row);
      const colB = Number(tileB.dataset.col);

      board[rowA][colA] = tileB;
      board[rowB][colB] = tileA;

      tileA.dataset.row = rowB;
      tileA.dataset.col = colB;
      tileB.dataset.row = rowA;
      tileB.dataset.col = colA;
    };

    const moveTile = (tile) => {
      const row = Number(tile.dataset.row);
      const col = Number(tile.dataset.col);
      const { x, y } = positionToPixels(row, col);
      tile.style.setProperty("--x", `${x}px`);
      tile.style.setProperty("--y", `${y}px`);
      tile.style.transform = `translate(${x}px, ${y}px)`;
    };

    const findMatches = () => {
      const matches = new Set();

      // Yatay kontrol
      for (let row = 0; row < gridSize; row += 1) {
        let count = 1;
        for (let col = 1; col <= gridSize; col += 1) {
          const current = board[row][col];
          const prev = board[row][col - 1];
          if (col < gridSize && current && prev && current.dataset.type === prev.dataset.type) {
            count += 1;
          } else {
            if (count >= 3) {
              for (let k = 0; k < count; k += 1) {
                matches.add(board[row][col - 1 - k]);
              }
            }
            count = 1;
          }
        }
      }

      // Dikey kontrol
      for (let col = 0; col < gridSize; col += 1) {
        let count = 1;
        for (let row = 1; row <= gridSize; row += 1) {
          const current = board[row] ? board[row][col] : null;
          const prev = board[row - 1][col];
          if (row < gridSize && current && prev && current.dataset.type === prev.dataset.type) {
            count += 1;
          } else {
            if (count >= 3) {
              for (let k = 0; k < count; k += 1) {
                matches.add(board[row - 1 - k][col]);
              }
            }
            count = 1;
          }
        }
      }

      return Array.from(matches);
    };

    const resolveMatches = async (matches, comboLevel) => {
      if (matches.length === 0) return;

      matches.forEach((tile) => {
        if (!tile) return;
        const sparkle = document.createElement("div");
        sparkle.className = "sparkles";
        tile.appendChild(sparkle);
        tile.classList.add("pop");
        const row = Number(tile.dataset.row);
        const col = Number(tile.dataset.col);
        board[row][col] = null;
      });

      updateCombo(comboLevel);
      updateScore(matches.length * 10 * comboLevel);
      await wait(320);

      matches.forEach((tile) => tile?.remove());

      await dropTiles();

      const newMatches = findMatches();
      if (newMatches.length > 0) {
        await resolveMatches(newMatches, comboLevel + 1);
      } else {
        updateCombo(1);
      }
    };

    const dropTiles = async () => {
      for (let col = 0; col < gridSize; col += 1) {
        let emptyCount = 0;
        for (let row = gridSize - 1; row >= 0; row -= 1) {
          if (!board[row][col]) {
            emptyCount += 1;
          } else if (emptyCount > 0) {
            const tile = board[row][col];
            board[row + emptyCount][col] = tile;
            board[row][col] = null;
            tile.dataset.row = row + emptyCount;
            moveTile(tile);
          }
        }

        for (let i = 0; i < emptyCount; i += 1) {
          const type = getRandomType();
          const tile = createTile(i, col, type);
          tile.dataset.row = i;
          tile.style.transform = `translate(${col * (tileSize + gap)}px, ${- (emptyCount - i) * (tileSize + gap)}px)`;
          board[i][col] = tile;
          requestAnimationFrame(() => moveTile(tile));
        }
      }

      await wait(260);
    };

    const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

    restartBtn.addEventListener("click", resetGame);

    buildBoard();
  </script>
</body>
</html>
